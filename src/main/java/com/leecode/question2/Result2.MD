两数相加
===		
题干		
---	
给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。		
		
你可以假设除了数字 0 之外，这两个数字都不会以零开头。		
		
示例：			
		
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)		
输出：7 -> 0 -> 8		
原因：342 + 465 = 807		

解答	
---		

当时遇到这个问题的时候首先先考虑是不是可以将这种形式的数字表示方法转换为用一个真实的long数字进行代替，相加后再转换回题目给出的形式。但是经过试验后发现由于给出的数字可能超出long类型的最大值，最终导致不能通过。虽然这种方式从时间效率的角度讲是最优的，long类型溢出的问题可以用BigDecimal来代替。但是这个解题方式是不合题意的。本问题其实是提供了一种高精度加法的解决算法，如果使用了语言自带的高度优化的高精度对象，固然是一个合理的解决办法，但是从算法的角度上讲并不能解决问题。		
所以对于这个问题，应该理解为基于链表的高精度加法，在这个理解上去做就好。
说白了就是根据加法的方式，逐位遍历两个链表，当前位相加并加上进位的数，若有进位则进位置为1，否贼为0，当前位的数字为加出来的结果的各位值。	
值得注意的是两个地方，首先是notOO里的做法并没有创建新的链表，为了速度快一些使用之前的老链表，串出最长的一串，此时就需要对链表如何结束进行判断：	
			1.由于将最长的一段链表串在L1上输出，则在遍历过程中如果l1链条比l2短（p1.next == null && p2.next != null），那么就将l1的末端指向l2的下一节上。（即p1.next = p2.next）相应的，如果p1==p2，那么就只需要计算p1.val + add并判断是否进位即可。
			2.需要考虑最高位进位问题，如果已经在最高位且进位大于0，则需要在p1.next处建立一个新的节点来容纳最后的一个1